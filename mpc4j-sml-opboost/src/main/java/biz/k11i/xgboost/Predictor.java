/*
 * Original Work Copyright 2018 H2O.ai.
 * Modified Work Copyright 2021 Weiran Liu.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package biz.k11i.xgboost;

import biz.k11i.xgboost.config.PredictorConfiguration;
import biz.k11i.xgboost.fvec.FVec;
import biz.k11i.xgboost.gbm.GradBoostModel;
import biz.k11i.xgboost.learner.ObjFunction;
import biz.k11i.xgboost.learner.ObjFunctionManager;
import biz.k11i.xgboost.spark.SparkModelParam;
import biz.k11i.xgboost.util.ModelReader;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;

/**
 * Predicts using the XGBoost model.
 *
 * @author KOMIYA Atsushi, KOMIYA Atsushi, Michal Kurka, Weiran Liu
 * @date 2021/10/08
 */
public class Predictor implements Serializable {
    private static final long serialVersionUID = -5397062830428346193L;
    /**
     * base score
     */
    private final float baseScore;
    /**
     * model param
     */
    private ModelParam modelParam;
    /**
     * spark model param
     */
    private SparkModelParam sparkModelParam;
    /**
     * objective function name
     */
    private String objName;
    /**
     * grad boost model name
     */
    private String gbmName;
    /**
     * objective function
     */
    private ObjFunction objFunction;
    /**
     * gradient booster
     */
    private GradBoostModel gradBoostModel;

    public Predictor(InputStream in) throws IOException {
        this(in, null);
    }

    /**
     * Instantiates with the XGBoost model.
     *
     * @param in            input stream.
     * @param configuration configuration.
     * @throws IOException If an I/O error occurs.
     */
    public Predictor(InputStream in, PredictorConfiguration configuration) throws IOException {
        if (configuration == null) {
            configuration = PredictorConfiguration.DEFAULT;
        }

        ModelReader reader = new ModelReader(in);

        readParam(reader);
        initObjFunction(configuration);
        initObjGbm();

        gradBoostModel.loadModel(configuration, reader, modelParam.pBuffer != 0);

        if (modelParam.majorVersion >= 1) {
            baseScore = objFunction.probToMargin(modelParam.baseScore);
        } else {
            baseScore = modelParam.baseScore;
        }
    }

    void readParam(ModelReader reader) throws IOException {
        byte[] first4Bytes = reader.readByteArray(4);
        byte[] next4Bytes = reader.readByteArray(4);

        float base_score;
        int num_feature;

        if (first4Bytes[0] == 0x62 &&
            first4Bytes[1] == 0x69 &&
            first4Bytes[2] == 0x6e &&
            first4Bytes[3] == 0x66) {

            // Old model file format has a signature "binf" (62 69 6e 66)
            base_score = reader.asFloat(next4Bytes);
            num_feature = reader.readUnsignedInt();

        } else if (first4Bytes[0] == 0x00 &&
            first4Bytes[1] == 0x05 &&
            first4Bytes[2] == 0x5f) {

            // Model generated by xgboost4j-spark?
            String modelType = null;
            if (first4Bytes[3] == 0x63 &&
                next4Bytes[0] == 0x6c &&
                next4Bytes[1] == 0x73 &&
                next4Bytes[2] == 0x5f) {
                // classification model
                modelType = SparkModelParam.MODEL_TYPE_CLS;

            } else if (first4Bytes[3] == 0x72 &&
                next4Bytes[0] == 0x65 &&
                next4Bytes[1] == 0x67 &&
                next4Bytes[2] == 0x5f) {
                // regression model
                modelType = SparkModelParam.MODEL_TYPE_REG;
            }

            if (modelType != null) {
                int len = (next4Bytes[3] << 8) + (reader.readByteAsInt());
                String featuresCol = reader.readUTF(len);

                this.sparkModelParam = new SparkModelParam(modelType, featuresCol, reader);

                base_score = reader.readFloat();
                num_feature = reader.readUnsignedInt();

            } else {
                base_score = reader.asFloat(first4Bytes);
                num_feature = reader.asUnsignedInt(next4Bytes);
            }

        } else {
            base_score = reader.asFloat(first4Bytes);
            num_feature = reader.asUnsignedInt(next4Bytes);
        }

        modelParam = new ModelParam(base_score, num_feature, reader);

        objName = reader.readString();
        gbmName = reader.readString();
    }

    void initObjFunction(PredictorConfiguration configuration) {
        objFunction = configuration.getObjFunction();

        if (objFunction == null) {
            objFunction = ObjFunctionManager.fromName(objName);
        }
    }

    void initObjGbm() {
        objFunction = ObjFunctionManager.fromName(objName);
        gradBoostModel = GradBoostModel.Factory.createGradBooster(gbmName);
        gradBoostModel.setNumClass(modelParam.numClass);
        gradBoostModel.setNumFeature(modelParam.featureNum);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat feature vector
     * @return prediction values
     */
    public float[] predict(FVec feat) {
        return predict(feat, false);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat          feature vector
     * @param output_margin whether to only predict margin value instead of transformed prediction
     * @return prediction values
     */
    public float[] predict(FVec feat, boolean output_margin) {
        return predict(feat, output_margin, 0);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat        feature vector
     * @param base_margin predict with base margin for each prediction
     * @return prediction values
     */
    public float[] predict(FVec feat, float base_margin) {
        return predict(feat, base_margin, 0);
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat        feature vector
     * @param base_margin predict with base margin for each prediction
     * @param ntree_limit limit the number of trees used in prediction
     * @return prediction values
     */
    public float[] predict(FVec feat, float base_margin, int ntree_limit) {
        float[] preds = predictRaw(feat, base_margin, ntree_limit);
        preds = objFunction.predTransform(preds);
        return preds;
    }

    /**
     * Generates predictions for given feature vector.
     *
     * @param feat          feature vector
     * @param output_margin whether to only predict margin value instead of transformed prediction
     * @param ntree_limit   limit the number of trees used in prediction
     * @return prediction values
     */
    public float[] predict(FVec feat, boolean output_margin, int ntree_limit) {
        float[] preds = predictRaw(feat, baseScore, ntree_limit);
        if (!output_margin) {
            preds = objFunction.predTransform(preds);
        }
        return preds;
    }

    float[] predictRaw(FVec feat, float base_score, int ntree_limit) {
        float[] preds = gradBoostModel.predict(feat, ntree_limit);
        for (int i = 0; i < preds.length; i++) {
            preds[i] += base_score;
        }
        return preds;
    }

    /**
     * Generates a prediction for given feature vector.
     * <p>
     * This method only works when the model outputs single value.
     * </p>
     *
     * @param featureVector feature vector.
     * @return prediction value.
     */
    public float predictSingle(FVec featureVector) {
        return predictSingle(featureVector, false);
    }

    /**
     * Generates a prediction for given feature vector.
     * <p>
     * This method only works when the model outputs single value.
     * </p>
     *
     * @param featureVector feature vector
     * @param outputMargin  whether to only predict margin value instead of transformed prediction
     * @return prediction value
     */
    public float predictSingle(FVec featureVector, boolean outputMargin) {
        return predictSingle(featureVector, outputMargin, 0);
    }

    /**
     * Generates a prediction for given feature vector.
     * <p>
     * This method only works when the model outputs single value.
     * </p>
     *
     * @param featureVector feature vector.
     * @param outputMargin  whether to only predict margin value instead of transformed prediction.
     * @param numTreeLimit  limit the number of trees used in prediction.
     * @return prediction value.
     */
    public float predictSingle(FVec featureVector, boolean outputMargin, int numTreeLimit) {
        float pred = predictSingleRaw(featureVector, numTreeLimit);
        if (!outputMargin) {
            pred = objFunction.predTransform(pred);
        }
        return pred;
    }

    float predictSingleRaw(FVec featureVector, int numTreeLimit) {
        return gradBoostModel.predictSingle(featureVector, numTreeLimit) + baseScore;
    }

    /**
     * Predicts leaf index of each tree.
     *
     * @param featureVector feature vector.
     * @return leaf indexes.
     */
    public int[] predictLeaf(FVec featureVector) {
        return predictLeaf(featureVector, 0);
    }

    /**
     * Predicts leaf index of each tree.
     *
     * @param featureVector        feature vector.
     * @param numTreeLimit limit, 0 for all.
     * @return leaf indexes.
     */
    public int[] predictLeaf(FVec featureVector, int numTreeLimit) {
        return gradBoostModel.predictLeaf(featureVector, numTreeLimit);
    }

    /**
     * Predicts path to leaf of each tree.
     *
     * @param featureVector feature vector.
     * @return leaf paths.
     */
    public String[] predictLeafPath(FVec featureVector) {
        return predictLeafPath(featureVector, 0);
    }

    /**
     * Predicts path to leaf of each tree.
     *
     * @param feat        feature vector.
     * @param ntree_limit limit, 0 for all.
     * @return leaf paths.
     */
    public String[] predictLeafPath(FVec feat, int ntree_limit) {
        return gradBoostModel.predictLeafPath(feat, ntree_limit);
    }

    public SparkModelParam getSparkModelParam() {
        return sparkModelParam;
    }

    /**
     * Returns number of class.
     *
     * @return number of class
     */
    public int getNumClass() {
        return modelParam.numClass;
    }

    /**
     * Parameters.
     */
    static class ModelParam implements Serializable {
        private static final long serialVersionUID = 5299651032520825971L;
        /**
         * global bias
         */
        final float baseScore;
        /**
         * number of features
         */
        final /* unsigned */ int featureNum;
        /**
         * number of class, if it is multi-class classification
         */
        final int numClass;
        /**
         * whether the model itself is saved with pBuffer
         */
        final int pBuffer;
        /**
         * Model contain eval metrics
         */
        final int containEvalMetrics;
        /**
         * the major version of XGBoost.
         */
        final int majorVersion;
        /**
         * the minor version of XGBoost.
         */
        final int minorVersion;
        /**
         * reserved field
         */
        final int[] reserved;

        ModelParam(float baseScore, int featureNum, ModelReader reader) throws IOException {
            this.baseScore = baseScore;
            this.featureNum = featureNum;
            this.numClass = reader.readInt();
            this.pBuffer = reader.readInt();
            this.containEvalMetrics = reader.readInt();
            this.majorVersion = reader.readUnsignedInt();
            this.minorVersion = reader.readUnsignedInt();
            this.reserved = reader.readIntArray(27);
        }
    }

    public GradBoostModel getBooster() {
        return gradBoostModel;
    }

    public String getObjName() {
        return objName;
    }

    public float getBaseScore() {
        return baseScore;
    }

}
