package edu.alibaba.mpc4j.s2pc.sbitmap.utils;

import edu.alibaba.mpc4j.common.tool.bitvector.BitVector;
import edu.alibaba.mpc4j.s2pc.sbitmap.RoaringBitmapTestUtils;
import org.junit.Assert;
import org.junit.Test;
import org.roaringbitmap.BitmapContainer;
import org.roaringbitmap.RoaringBitmap;

import java.util.Random;

/**
 * tests for RoaringBitmap utilities.
 *
 * @author Weiran Liu
 * @date 2022/12/28
 */
public class RoaringBitmapUtilsTest {
    /**
     * default max number of bits
     */
    private static final int MAX_BIT_NUM = 1000000;

    @Test
    public void testCheckValidBitNum() {
        // -1 is not a valid maxBitNum
        Assert.assertThrows(IllegalArgumentException.class, () -> RoaringBitmapUtils.checkValidMaxBitNum(-1));
        // 0 is not a valid maxBitNum
        Assert.assertThrows(IllegalArgumentException.class, () -> RoaringBitmapUtils.checkValidMaxBitNum(0));
        // 1 is not a valid maxBitNum
        Assert.assertThrows(IllegalArgumentException.class, () -> RoaringBitmapUtils.checkValidMaxBitNum(1));
        // BitmapContainer.MAX_CAPACITY - 1 is not a valid maxBitNum
        Assert.assertThrows(IllegalArgumentException.class, () ->
            RoaringBitmapUtils.checkValidMaxBitNum(BitmapContainer.MAX_CAPACITY - 1)
        );
        // BitmapContainer.MAX_CAPACITY is a valid maxBitNum
        RoaringBitmapUtils.checkValidMaxBitNum(BitmapContainer.MAX_CAPACITY);
        // BitmapContainer.MAX_CAPACITY + 1 is not a valid maxBitNum
        Assert.assertThrows(IllegalArgumentException.class, () ->
            RoaringBitmapUtils.checkValidMaxBitNum(BitmapContainer.MAX_CAPACITY + 1)
        );
        // BitmapContainer.MAX_CAPACITY * 2 - 1 is not a valid maxBitNum
        Assert.assertThrows(IllegalArgumentException.class, () ->
            RoaringBitmapUtils.checkValidMaxBitNum(BitmapContainer.MAX_CAPACITY * 2 - 1)
        );
        // BitmapContainer.MAX_CAPACITY * 2 is a valid maxBitNum
        RoaringBitmapUtils.checkValidMaxBitNum(BitmapContainer.MAX_CAPACITY);
        // BitmapContainer.MAX_CAPACITY * 2 + 1 is not a valid maxBitNum
        Assert.assertThrows(IllegalArgumentException.class, () ->
            RoaringBitmapUtils.checkValidMaxBitNum(BitmapContainer.MAX_CAPACITY * 2 + 1)
        );
    }

    @Test
    public void testCheckContainValidBits() {
        // try containing negative integer
        Assert.assertThrows(IllegalArgumentException.class, () -> {
            RoaringBitmap roaringBitmap = RoaringBitmap.bitmapOf(-1);
            RoaringBitmapUtils.checkContainValidBits(1, roaringBitmap);
        });
        // try containing large integer
        Assert.assertThrows(IllegalArgumentException.class, () -> {
            RoaringBitmap roaringBitmap = RoaringBitmap.bitmapOf(0, 1, 2);
            RoaringBitmapUtils.checkContainValidBits(1, roaringBitmap);
        });
        // try containing bound integer
        Assert.assertThrows(IllegalArgumentException.class, () -> {
            RoaringBitmap roaringBitmap = RoaringBitmap.bitmapOf(0, 1, 2);
            RoaringBitmapUtils.checkContainValidBits(2, roaringBitmap);
        });
    }

    @Test
    public void testEmptyRoaringBitmapToBitVector() {
        // new RoaringBitmap
        RoaringBitmap newBitmap0 = new RoaringBitmap();
        BitVector newBitVector = RoaringBitmapUtils.toBitVector(MAX_BIT_NUM, newBitmap0);
        RoaringBitmap newBitmap1 = RoaringBitmapUtils.toRoaringBitmap(newBitVector);
        Assert.assertEquals(newBitmap0, newBitmap1);
        // create RoaringBitmap with 0-length int array
        RoaringBitmap zeroArrayBitmap0 = RoaringBitmap.bitmapOf();
        BitVector zeroArrayBitVector = RoaringBitmapUtils.toBitVector(MAX_BIT_NUM, zeroArrayBitmap0);
        RoaringBitmap zeroArrayBitmap1 = RoaringBitmapUtils.toRoaringBitmap(zeroArrayBitVector);
        Assert.assertEquals(zeroArrayBitmap0, zeroArrayBitmap1);
    }

    @Test
    public void testRandomRoaringBitmapToBitVector() {
        // test bitmap generated by unsorted int array
        RoaringBitmap randomUnsortedBitmap0 = getUnsortedRandomRoaringBitmap();
        BitVector randomUnsortedBitVector
            = RoaringBitmapUtils.toBitVector(MAX_BIT_NUM, randomUnsortedBitmap0);
        RoaringBitmap randomUnsortedBitmap1 = RoaringBitmapUtils.toRoaringBitmap(randomUnsortedBitVector);
        Assert.assertEquals(randomUnsortedBitmap0, randomUnsortedBitmap1);
        // test bitmap generated by sorted int array
        RoaringBitmap randomSortedBitmap0 = getSortedRandomRoaringBitmap();
        BitVector randomSortedBitVector
            = RoaringBitmapUtils.toBitVector(MAX_BIT_NUM, randomSortedBitmap0);
        RoaringBitmap randomSortedBitmap1 = RoaringBitmapUtils.toRoaringBitmap(randomSortedBitVector);
        Assert.assertEquals(randomSortedBitmap0, randomSortedBitmap1);
    }

    @Test
    public void testFullRoaringBitmapToBitVector() {
        RoaringBitmap fullBitmap0 = RoaringBitmap.bitmapOfRange(0, MAX_BIT_NUM);
        BitVector fullBitVector = RoaringBitmapUtils.toBitVector(MAX_BIT_NUM, fullBitmap0);
        RoaringBitmap fullBitmap1 = RoaringBitmapUtils.toRoaringBitmap(fullBitVector);
        Assert.assertEquals(fullBitmap0, fullBitmap1);
    }

    @Test
    public void testEmptyRoaringBitmapToRoaringBitVectors() {
        // new RoaringBitmap
        RoaringBitmap newBitmap0 = new RoaringBitmap();
        char[] newKeys = RoaringBitmapUtils.getKeyCharArray(newBitmap0);
        BitVector[] newRoaringBitVectors = RoaringBitmapUtils.toRoaringBitVectors(MAX_BIT_NUM, newBitmap0);
        RoaringBitmap newBitmap1 = RoaringBitmapUtils.toRoaringBitmap(newKeys, newRoaringBitVectors);
        Assert.assertEquals(newBitmap0, newBitmap1);
        // create RoaringBitmap with 0-length int array
        RoaringBitmap zeroArrayBitmap0 = RoaringBitmap.bitmapOf();
        char[] zeroArrayKeys = RoaringBitmapUtils.getKeyCharArray(zeroArrayBitmap0);
        BitVector[] zeroArrayRoaringBitVectors = RoaringBitmapUtils.toRoaringBitVectors(MAX_BIT_NUM, zeroArrayBitmap0);
        RoaringBitmap zeroArrayBitmap1 = RoaringBitmapUtils.toRoaringBitmap(zeroArrayKeys, zeroArrayRoaringBitVectors);
        Assert.assertEquals(zeroArrayBitmap0, zeroArrayBitmap1);
    }

    @Test
    public void testRandomRoaringBitmapToRoaringBitVectors() {
        // test bitmap generated by unsorted int array
        RoaringBitmap randomUnsortedBitmap0 = getUnsortedRandomRoaringBitmap();
        char[] randomUnsortedKeys = RoaringBitmapUtils.getKeyCharArray(randomUnsortedBitmap0);
        BitVector[] randomUnsortedRoaringBitVectors = RoaringBitmapUtils.toRoaringBitVectors(
            MAX_BIT_NUM, randomUnsortedBitmap0
        );
        RoaringBitmap randomUnsortedBitmap1
            = RoaringBitmapUtils.toRoaringBitmap(randomUnsortedKeys, randomUnsortedRoaringBitVectors);
        Assert.assertEquals(randomUnsortedBitmap0, randomUnsortedBitmap1);
        // test bitmap generated by sorted int array
        RoaringBitmap randomSortedBitmap0 = getSortedRandomRoaringBitmap();
        char[] randomSortedKeys = RoaringBitmapUtils.getKeyCharArray(randomSortedBitmap0);
        BitVector[] randomSortedRoaringBitVectors = RoaringBitmapUtils.toRoaringBitVectors(
            MAX_BIT_NUM, randomSortedBitmap0
        );
        RoaringBitmap randomSortedBitmap1
            = RoaringBitmapUtils.toRoaringBitmap(randomSortedKeys, randomSortedRoaringBitVectors);
        Assert.assertEquals(randomSortedBitmap0, randomSortedBitmap1);
    }

    @Test
    public void testFullRoaringBitmapToRoaringBitVectors() {
        RoaringBitmap fullBitmap0 = RoaringBitmap.bitmapOfRange(0, MAX_BIT_NUM);
        char[] fullKeys = RoaringBitmapUtils.getKeyCharArray(fullBitmap0);
        BitVector[] fullRoaringBitVectors = RoaringBitmapUtils.toRoaringBitVectors(MAX_BIT_NUM, fullBitmap0);
        RoaringBitmap fullBitmap1 = RoaringBitmapUtils.toRoaringBitmap(fullKeys, fullRoaringBitVectors);
        Assert.assertEquals(fullBitmap0, fullBitmap1);
    }

    private RoaringBitmap getSortedRandomRoaringBitmap() {
        final int[] data = RoaringBitmapTestUtils.takeSortedAndDistinct(
            new Random(0xcb000a2b9b5bdfb6L), MAX_BIT_NUM / 10, MAX_BIT_NUM
        );
        RoaringBitmap randomBitmap = RoaringBitmap.bitmapOf(data);
        updateBitmap(randomBitmap);
        return randomBitmap;
    }

    private RoaringBitmap getUnsortedRandomRoaringBitmap() {
        Random random = new Random(0xcb000a2b9b5bdfb6L);
        // generate parts data in [2/4, 3/4)
        final int[] thirdQuantileData = RoaringBitmapTestUtils.takeSortedAndDistinct(
            random, MAX_BIT_NUM / 40, MAX_BIT_NUM / 4 * 2, MAX_BIT_NUM / 4 * 3
        );
        RoaringBitmap randomBitmap = RoaringBitmap.bitmapOf(thirdQuantileData);
        // generate parts data in [3/4, 1)
        final int[] fourthQuantileData = RoaringBitmapTestUtils.takeSortedAndDistinct(
            random, MAX_BIT_NUM / 40, MAX_BIT_NUM / 4 * 3, MAX_BIT_NUM
        );
        randomBitmap.add(fourthQuantileData);
        // generate parts data in [0, 2/4)
        final int[] halfQuantileData = RoaringBitmapTestUtils.takeSortedAndDistinct(
            random, MAX_BIT_NUM / 20, MAX_BIT_NUM / 4 * 2
        );
        randomBitmap.add(halfQuantileData);
        updateBitmap(randomBitmap);
        return randomBitmap;
    }

    private void updateBitmap(RoaringBitmap randomBitmap) {
        // bitmap density and too many little runs
        for (int k = MAX_BIT_NUM / 10; k < MAX_BIT_NUM / 10 * 2; k++) {
            randomBitmap.add(3 * k);
        }
        // RunContainer would be best
        for (int k = MAX_BIT_NUM / 10 * 7; k < MAX_BIT_NUM / 10 * 8; k++) {
            randomBitmap.add(k);
        }
        // mix of all 3 container kinds
        randomBitmap.runOptimize();
    }
}
