package edu.alibaba.mpc4j.crypto.fhe;

import edu.alibaba.mpc4j.crypto.fhe.context.Context;
import edu.alibaba.mpc4j.crypto.fhe.keys.*;
import edu.alibaba.mpc4j.crypto.fhe.modulus.Modulus;
import edu.alibaba.mpc4j.crypto.fhe.ntt.NttTables;
import edu.alibaba.mpc4j.crypto.fhe.ntt.NttTool;
import edu.alibaba.mpc4j.crypto.fhe.params.EncryptionParams;
import edu.alibaba.mpc4j.crypto.fhe.rq.PolyArithmeticSmallMod;
import edu.alibaba.mpc4j.crypto.fhe.utils.Constants;
import edu.alibaba.mpc4j.crypto.fhe.utils.GaloisTool;
import edu.alibaba.mpc4j.crypto.fhe.utils.RingLwe;
import edu.alibaba.mpc4j.crypto.fhe.utils.ValueChecker;
import edu.alibaba.mpc4j.crypto.fhe.zq.Common;
import edu.alibaba.mpc4j.crypto.fhe.zq.UintArithmeticSmallMod;

import java.util.stream.IntStream;

/**
 * @author Qixian Zhou
 * @date 2023/9/14
 */
public class KeyGenerator {

    private Context context;

    private SecretKey secretKey;

    private int secretKeyArraySize = 0;

    private long[] secretKeyArray;

    boolean skGenerated = false;


    public KeyGenerator(Context context) {

        if (!context.isParametersSet()) {
            throw new IllegalArgumentException("encryption parameters are not set correctly");
        }
        this.context = context;
        // Secret key has not been generated
        skGenerated = false;
        // Generate the secret and public key
        generateSk(false);
    }

    public KeyGenerator(Context context, SecretKey secretKey) {

        if (!context.isParametersSet()) {
            throw new IllegalArgumentException("encryption parameters are not set correctly");
        }
        if (ValueChecker.isValidFor(secretKey, context)) {
            throw new IllegalArgumentException("secret key is not valid for encryption parameters");
        }

        this.secretKey = secretKey;
        skGenerated = true;
        // only need to compute secretKeyArray
        generateSk(true);
    }


    public SecretKey getSecretKey() {
        return secretKey;
    }



    private void generateSk(boolean isInitialized) {

        // Extract encryption parameters.
        Context.ContextData contextData = context.keyContextData();
        EncryptionParams params = contextData.getParms();
        Modulus[] coeffModulus = params.getCoeffModulus();
        int coeffCount = params.getPolyModulusDegree(); // N
        int coeffModulusSize = coeffModulus.length; // k

        if (!isInitialized) {

            secretKey = new SecretKey();
            skGenerated = false;
            // RNS 表示下 需要 k 个 Poly, 每个 Poly 有 N 个 slots
            // todo: need mulSafe?
            secretKey.data().resize(Common.mulSafe(coeffCount, coeffModulusSize, false));
            // Generate secret key
            RingLwe.samplePolyTernary(params.getRandomGeneratorFactory().create(), params, secretKey.data().getData());

//            StringBuilder sb = new StringBuilder();
//            sb.append("sk: {");
//            for (int i = 0; i < secretKey.data().getData().length; i++) {
//                sb.append(secretKey.data().getData()[i]);
//                if (i != secretKey.data().getData().length - 1) {
//                    sb.append(", ");
//                }
//            }
//            sb.append("}");
//            System.out.println(sb);
//
//            sb = new StringBuilder();
//            sb.append("sk: {");
//            for (int i = 0; i < secretKey.data().getData().length; i++) {
//                sb.append(secretKey.data().getData()[i]);
//                sb.append("L");
//                if (i != secretKey.data().getData().length - 1) {
//                    sb.append(", ");
//                }
//            }
//            sb.append("}");
//            System.out.println(sb);
//            long[] data = new long[] {0L, 1L, 1L, 1099511590912L, 0L, 0L, 0L, 1099511590912L, 0L, 1099511590912L, 1099511590912L, 0L, 1099511590912L, 1099511590912L, 1099511590912L, 1099511590912L, 1L, 0L, 0L, 1099511590912L, 1099511590912L, 1L, 1099511590912L, 1099511590912L, 0L, 0L, 1L, 0L, 0L, 1L, 1099511590912L, 0L, 1099511590912L, 1L, 1099511590912L, 0L, 0L, 0L, 1099511590912L, 0L, 1L, 1099511590912L, 1099511590912L, 1L, 0L, 0L, 1L, 0L, 1099511590912L, 1L, 1099511590912L, 1L, 1L, 1099511590912L, 0L, 0L, 1L, 0L, 1L, 1099511590912L, 1L, 1099511590912L, 1L, 1L, 1L, 1L, 1L, 0L, 0L, 0L, 1099511590912L, 1099511590912L, 1099511590912L, 1099511590912L, 1L, 1099511590912L, 0L, 0L, 0L, 0L, 1L, 1099511590912L, 1099511590912L, 0L, 1L, 1099511590912L, 0L, 1L, 0L, 1L, 1L, 0L, 1099511590912L, 1099511590912L, 1099511590912L, 1L, 1L, 0L, 0L, 1099511590912L, 1L, 1L, 1L, 0L, 1L, 1L, 1L, 1099511590912L, 1099511590912L, 1099511590912L, 0L, 1099511590912L, 0L, 1L, 0L, 1099511590912L, 1099511590912L, 0L, 1099511590912L, 0L, 1099511590912L, 0L, 1L, 1L, 1L, 1L, 1099511590912L, 1L, 1L, 0L, 0L, 1099511590912L, 1L, 1L, 1L, 0L, 1099511590912L, 1L, 1099511590912L, 1L, 1L, 0L, 1099511590912L, 1L, 0L, 1099511590912L, 1099511590912L, 0L, 1L, 0L, 0L, 1L, 1099511590912L, 1L, 1L, 1L, 0L, 0L, 1099511590912L, 1L, 1099511590912L, 1L, 1L, 0L, 1099511590912L, 1L, 1099511590912L, 1099511590912L, 1L, 1099511590912L, 1099511590912L, 0L, 1099511590912L, 1099511590912L, 1099511590912L, 1099511590912L, 1L, 0L, 0L, 1099511590912L, 0L, 1099511590912L, 0L, 1L, 1099511590912L, 0L, 1L, 1L, 0L, 1L, 0L, 1099511590912L, 1L, 0L, 0L, 1099511590912L, 1L, 0L, 1L, 1099511590912L, 0L, 0L, 1099511590912L, 1099511590912L, 1L, 1099511590912L, 1L, 1099511590912L, 0L, 1L, 1L, 1099511590912L, 0L, 0L, 0L, 0L, 1L, 1099511590912L, 1099511590912L, 1L, 1099511590912L, 1099511590912L, 0L, 1099511590912L, 0L, 1099511590912L, 1099511590912L, 1L, 1L, 1L, 0L, 1099511590912L, 1L, 1L, 1L, 1099511590912L, 0L, 1099511590912L, 1L, 1099511590912L, 0L, 1L, 1L, 0L, 1L, 1L, 0L, 1099511590912L, 1L, 1099511590912L, 1L, 1L, 1L, 1L, 0L, 1L, 0L, 1L, 1L, 1099511592960L, 0L, 0L, 0L, 1099511592960L, 0L, 1099511592960L, 1099511592960L, 0L, 1099511592960L, 1099511592960L, 1099511592960L, 1099511592960L, 1L, 0L, 0L, 1099511592960L, 1099511592960L, 1L, 1099511592960L, 1099511592960L, 0L, 0L, 1L, 0L, 0L, 1L, 1099511592960L, 0L, 1099511592960L, 1L, 1099511592960L, 0L, 0L, 0L, 1099511592960L, 0L, 1L, 1099511592960L, 1099511592960L, 1L, 0L, 0L, 1L, 0L, 1099511592960L, 1L, 1099511592960L, 1L, 1L, 1099511592960L, 0L, 0L, 1L, 0L, 1L, 1099511592960L, 1L, 1099511592960L, 1L, 1L, 1L, 1L, 1L, 0L, 0L, 0L, 1099511592960L, 1099511592960L, 1099511592960L, 1099511592960L, 1L, 1099511592960L, 0L, 0L, 0L, 0L, 1L, 1099511592960L, 1099511592960L, 0L, 1L, 1099511592960L, 0L, 1L, 0L, 1L, 1L, 0L, 1099511592960L, 1099511592960L, 1099511592960L, 1L, 1L, 0L, 0L, 1099511592960L, 1L, 1L, 1L, 0L, 1L, 1L, 1L, 1099511592960L, 1099511592960L, 1099511592960L, 0L, 1099511592960L, 0L, 1L, 0L, 1099511592960L, 1099511592960L, 0L, 1099511592960L, 0L, 1099511592960L, 0L, 1L, 1L, 1L, 1L, 1099511592960L, 1L, 1L, 0L, 0L, 1099511592960L, 1L, 1L, 1L, 0L, 1099511592960L, 1L, 1099511592960L, 1L, 1L, 0L, 1099511592960L, 1L, 0L, 1099511592960L, 1099511592960L, 0L, 1L, 0L, 0L, 1L, 1099511592960L, 1L, 1L, 1L, 0L, 0L, 1099511592960L, 1L, 1099511592960L, 1L, 1L, 0L, 1099511592960L, 1L, 1099511592960L, 1099511592960L, 1L, 1099511592960L, 1099511592960L, 0L, 1099511592960L, 1099511592960L, 1099511592960L, 1099511592960L, 1L, 0L, 0L, 1099511592960L, 0L, 1099511592960L, 0L, 1L, 1099511592960L, 0L, 1L, 1L, 0L, 1L, 0L, 1099511592960L, 1L, 0L, 0L, 1099511592960L, 1L, 0L, 1L, 1099511592960L, 0L, 0L, 1099511592960L, 1099511592960L, 1L, 1099511592960L, 1L, 1099511592960L, 0L, 1L, 1L, 1099511592960L, 0L, 0L, 0L, 0L, 1L, 1099511592960L, 1099511592960L, 1L, 1099511592960L, 1099511592960L, 0L, 1099511592960L, 0L, 1099511592960L, 1099511592960L, 1L, 1L, 1L, 0L, 1099511592960L, 1L, 1L, 1L, 1099511592960L, 0L, 1099511592960L, 1L, 1099511592960L, 0L, 1L, 1L, 0L, 1L, 1L, 0L, 1099511592960L, 1L, 1099511592960L, 1L, 1L, 1L, 1L, 0L, 1L, 0L, 1L, 1L, 1099511603712L, 0L, 0L, 0L, 1099511603712L, 0L, 1099511603712L, 1099511603712L, 0L, 1099511603712L, 1099511603712L, 1099511603712L, 1099511603712L, 1L, 0L, 0L, 1099511603712L, 1099511603712L, 1L, 1099511603712L, 1099511603712L, 0L, 0L, 1L, 0L, 0L, 1L, 1099511603712L, 0L, 1099511603712L, 1L, 1099511603712L, 0L, 0L, 0L, 1099511603712L, 0L, 1L, 1099511603712L, 1099511603712L, 1L, 0L, 0L, 1L, 0L, 1099511603712L, 1L, 1099511603712L, 1L, 1L, 1099511603712L, 0L, 0L, 1L, 0L, 1L, 1099511603712L, 1L, 1099511603712L, 1L, 1L, 1L, 1L, 1L, 0L, 0L, 0L, 1099511603712L, 1099511603712L, 1099511603712L, 1099511603712L, 1L, 1099511603712L, 0L, 0L, 0L, 0L, 1L, 1099511603712L, 1099511603712L, 0L, 1L, 1099511603712L, 0L, 1L, 0L, 1L, 1L, 0L, 1099511603712L, 1099511603712L, 1099511603712L, 1L, 1L, 0L, 0L, 1099511603712L, 1L, 1L, 1L, 0L, 1L, 1L, 1L, 1099511603712L, 1099511603712L, 1099511603712L, 0L, 1099511603712L, 0L, 1L, 0L, 1099511603712L, 1099511603712L, 0L, 1099511603712L, 0L, 1099511603712L, 0L, 1L, 1L, 1L, 1L, 1099511603712L, 1L, 1L, 0L, 0L, 1099511603712L, 1L, 1L, 1L, 0L, 1099511603712L, 1L, 1099511603712L, 1L, 1L, 0L, 1099511603712L, 1L, 0L, 1099511603712L, 1099511603712L, 0L, 1L, 0L, 0L, 1L, 1099511603712L, 1L, 1L, 1L, 0L, 0L, 1099511603712L, 1L, 1099511603712L, 1L, 1L, 0L, 1099511603712L, 1L, 1099511603712L, 1099511603712L, 1L, 1099511603712L, 1099511603712L, 0L, 1099511603712L, 1099511603712L, 1099511603712L, 1099511603712L, 1L, 0L, 0L, 1099511603712L, 0L, 1099511603712L, 0L, 1L, 1099511603712L, 0L, 1L, 1L, 0L, 1L, 0L, 1099511603712L, 1L, 0L, 0L, 1099511603712L, 1L, 0L, 1L, 1099511603712L, 0L, 0L, 1099511603712L, 1099511603712L, 1L, 1099511603712L, 1L, 1099511603712L, 0L, 1L, 1L, 1099511603712L, 0L, 0L, 0L, 0L, 1L, 1099511603712L, 1099511603712L, 1L, 1099511603712L, 1099511603712L, 0L, 1099511603712L, 0L, 1099511603712L, 1099511603712L, 1L, 1L, 1L, 0L, 1099511603712L, 1L, 1L, 1L, 1099511603712L, 0L, 1099511603712L, 1L, 1099511603712L, 0L, 1L, 1L, 0L, 1L, 1L, 0L, 1099511603712L, 1L, 1099511603712L, 1L, 1L, 1L, 1L, 0L, 1L};

//            secretKey.data().set(data);

            // Transform the secret s into NTT representation.
            NttTables[] nttTables = contextData.getSmallNttTables();
            // k * N, 以其中每一个 N 为单位进行 nttForward
            NttTool.nttNegAcyclicHarveyRnsIter(secretKey.data().getData(), coeffCount, coeffModulusSize, nttTables);

            // Set the parms_id for secret key
            // TODO: here need deep-copy?
            secretKey.setParmsId(contextData.getParmsId().clone());
        }
        // Set the secret_key_array to have size 1 (first power of secret)
        secretKeyArray = new long[coeffCount * coeffModulusSize];
        // TODO: why need copy?
        System.arraycopy(secretKey.data().getData(), 0, secretKeyArray, 0, coeffCount * coeffModulusSize);
        secretKeyArraySize = 1;

        skGenerated = true;
    }

    public void createPublicKey(PublicKey destination) {
        generatePk(false, destination);
    }

    public void createRelinKeys(RelinKeys relinKeys) {
        createRelinKeys(1, false, relinKeys);
    }

    /**
     * todo: convert return type to Serializable<RelinKeys>
     *
     * @return
     */
    public RelinKeys createRelinKeys() {
        return createRelinKeys(1, false);
    }

    public void createGaloisKeys(int[] galoisElts, GaloisKeys destination) {
        createGaloisKeys(galoisElts, false, destination);
    }

    public void createGaloisKeys(GaloisKeys destination) {
        createGaloisKeys(
                context.keyContextData().getGaloisTool().getEltsAll()
                , destination);
    }

    /**
     * todo: convert return type to Serializable<RelinKeys>
     *
     * @return
     */
    public GaloisKeys createGaloisKeys() {
        return createGaloisKeys(context.keyContextData().getGaloisTool().getEltsAll());
    }

    /**
     * todo: convert return type to Serializable<RelinKeys>
     *
     * @param galoisElts
     * @return
     */
    public GaloisKeys createGaloisKeys(int[] galoisElts) {
        return createGaloisKeys(galoisElts, false);
    }


    public void createGaloisKeysFromSteps(int[] steps, GaloisKeys destination) {

        if (!context.keyContextData().getQualifiers().isUsingBatching()) {
            throw new IllegalArgumentException("encryption parameters do not support batching");
        }

        createGaloisKeys(context.keyContextData().getGaloisTool().getEltsFromSteps(steps), false, destination);
    }


    private PublicKey generatePk(boolean saveSeed) {

        if (!skGenerated) {
            throw new IllegalArgumentException("cannot generate public key for unspecified secret key");
        }

        Context.ContextData contextData = context.keyContextData();
        EncryptionParams parms = contextData.getParms();
        Modulus[] coeffModulus = parms.getCoeffModulus();
        int coeffCount = parms.getPolyModulusDegree();
        int coeffModulusSize = coeffModulus.length;

        // size check , todo: can remove?
        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize)) {
            throw new IllegalArgumentException("valid parameters");
        }

        PublicKey publicKey = new PublicKey();
        RingLwe.encryptZeroSymmetric(secretKey, context, contextData.getParmsId(), true, saveSeed, publicKey.data());

        // set the parmsId
        // todo: really need deep-copy?
        publicKey.setParmsId(contextData.getParmsId().clone());

        return publicKey;
    }

    private void generatePk(boolean saveSeed, PublicKey publicKey) {

        if (!skGenerated) {
            throw new IllegalArgumentException("cannot generate public key for unspecified secret key");
        }

        Context.ContextData contextData = context.keyContextData();
        EncryptionParams parms = contextData.getParms();
        Modulus[] coeffModulus = parms.getCoeffModulus();
        int coeffCount = parms.getPolyModulusDegree();
        int coeffModulusSize = coeffModulus.length;

        // size check , todo: can remove?
        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize)) {
            throw new IllegalArgumentException("valid parameters");
        }

        RingLwe.encryptZeroSymmetric(secretKey, context, contextData.getParmsId(), true, saveSeed, publicKey.data());

//        StringBuilder sb = new StringBuilder();
//        sb.append("pk: {");
//        for (int i = 0; i < publicKey.data().getData().length; i++) {
//            sb.append(publicKey.data().getData()[i]);
//            sb.append("L");
//            if (i != publicKey.data().getData().length - 1) {
//                sb.append(", ");
//            }
//        }
//        sb.append("}");
//        System.out.println(sb);
//
//        sb = new StringBuilder();
//        sb.append("pk: {");
//        for (int i = 0; i < publicKey.data().getData().length; i++) {
//            sb.append(publicKey.data().getData()[i]);
//            if (i != publicKey.data().getData().length - 1) {
//                sb.append(", ");
//            }
//        }
//        sb.append("}");
//        System.out.println(sb);


//        long[] data = new long[]{847229259165L, 974702945353L, 155060269945L, 746182875984L, 151873448233L, 66022925561L, 176566010391L,
//                146314611482L, 535917839790L, 386035021914L, 77332763604L, 259617732600L, 721666963949L, 345603525852L,
//                892241889904L, 892812388999L, 1008454880080L, 819138193568L, 280089058088L, 981603046062L, 561938220374L,
//                276828920343L, 965613287931L, 255769567705L, 280246705658L, 846286883432L, 918968805705L, 737977770115L,
//                244480517694L, 393748138224L, 575705717211L, 896503789789L, 1010445955697L, 259983704038L,
//                897098997852L, 96489756973L, 166786456601L, 1026847732671L, 724768496122L, 199761543731L,
//                917389326610L, 860709436647L, 358962203929L, 51224056074L, 728946779535L, 549372714839L, 147171551831L, 530249122355L,
//                711639403333L, 273421062187L, 419002641314L, 6085607355L, 649559163382L, 218550696163L, 50755786557L, 630049767883L, 510370849857L, 95052312664L, 309944176863L, 245046552478L, 430575750546L, 377502407355L, 777227542292L, 316200946317L, 385383677964L, 820142862448L, 126780473311L, 848718015708L, 364935529699L, 1052376290621L, 964674952724L, 613273420361L, 841161152946L, 1099203556972L, 717273118763L, 812247857655L, 135623770740L, 243596992472L, 947549512759L, 532146590608L, 106372722008L, 36672870607L, 325411682561L, 213391300572L, 170867202194L, 1006174938295L, 55155598087L, 645165433408L, 222990649416L, 573090116955L, 71628145895L, 407162453076L, 774382466068L, 902119865533L, 455626246657L, 635342560216L, 125764799391L, 689049024553L, 955994476153L, 103355862883L, 970170198011L, 941343647770L, 458573385930L, 689014491471L, 626618134919L, 358358171183L, 624423864845L, 799266910143L, 435638863963L, 489628532964L, 248778689865L, 1065849325251L, 947704335361L, 58613663171L, 627402567057L, 192958133381L, 638752305796L, 740426495343L, 1002373366313L, 702809684442L, 547570673826L, 24686057196L, 990215908601L, 859075303201L, 771164780751L, 439213100568L, 135980965045L, 790819692593L, 658506904789L, 48280281599L, 1032459405440L, 739136403507L, 892582772062L, 295073733533L, 493058716786L, 529013349103L, 339376698605L, 804598669784L, 207160839943L, 971494724479L, 598439577327L, 461708987521L, 123581778677L, 13212128550L, 987715713894L, 148195147103L, 189361713772L, 70996677981L, 275050151517L, 883634886039L, 954709671777L, 7869993445L, 1080086238878L, 237041325707L, 267283557387L, 182636508915L, 901802095904L, 720197857184L, 601623433906L, 585096449954L, 789974227100L, 821571297287L, 450489738415L, 408400048285L, 1095185047718L, 705596223739L, 796571614788L, 136533957329L, 336326378278L, 807444164881L, 588091844239L, 932691157383L, 777632336810L, 456619646469L, 1093477578814L, 238432802699L, 138802256456L, 486771873826L, 123452309086L, 743912998571L, 705762888490L, 721428120199L, 193760148538L, 881070394699L, 415372808161L, 850814443581L, 95455524088L, 309854774635L, 948159179167L, 424490894629L, 508279902929L, 878828424916L, 1011637764317L, 370784890377L, 943168510965L, 469806372621L, 768864455790L, 518723674533L, 407064118603L, 400382847371L, 599802921819L, 499272024703L, 48867408021L, 380460230258L, 253448317088L, 161402252293L, 418833784482L, 116090364424L, 279494985069L, 189182915545L, 381239217457L, 549825700074L, 248285631031L, 40180856098L, 977633580432L, 446093804470L, 560422922538L, 839627635623L, 1055884556732L, 810698090873L, 122814857819L, 568610204298L, 389455551522L, 1016123231559L, 22288040891L, 839927237877L, 272913504704L, 695152645738L, 371359678632L, 992934370210L, 400618999072L, 636556117778L, 992441693026L, 338637000766L, 272400158823L, 394766301495L, 815868885615L, 861635648760L, 959231253282L, 245989987897L, 719241456630L, 634264689919L, 96697205913L, 728065839354L, 368960781890L, 389040054237L, 136639146701L, 44089176796L, 429192601007L, 163226545206L, 171570514389L, 1075031264142L, 137470657155L, 948601162066L, 177794082598L, 821998182298L, 799807654740L, 493158420374L, 265578354714L, 306436276169L, 893187852430L, 1006927690234L, 133641248816L, 629941447237L, 899554188940L, 114091046700L, 1033285683726L, 1013224771745L, 672694584282L, 852636364309L, 824722982700L, 292365225318L, 413214375778L, 979553731768L, 438330583477L, 661581354966L, 69009077994L, 224904198481L, 927063139292L, 147913167477L, 490912145896L, 408865499649L, 1058007785929L, 408726437458L, 458491231427L, 661942600686L, 892659583297L, 597429446697L, 726284429458L, 623839018484L, 1085839103566L, 811264544103L, 718277594044L, 437498568397L, 533322951476L, 769892871984L, 598024773527L, 1071188692601L, 473018190508L, 508624983238L, 294123047919L, 340447480862L, 197954606104L, 538449560489L, 98626023780L, 540873758363L, 451139165196L, 419468260751L, 373181023755L, 306039878012L, 283712219532L, 539157220192L, 636552547631L, 41390183008L, 141558510909L, 215646903646L, 901421600168L, 615845292476L, 938161477116L, 831523648456L, 407971548461L, 46100153705L, 982066076518L, 881743443983L, 886025115170L, 887812807388L, 211676734156L, 101854563664L, 446435626836L, 92725611647L, 517593371551L, 650193055660L, 284930778381L, 259422081516L, 881684098711L, 893053428515L, 251473931891L, 941064642685L, 676236966188L, 73030450362L, 572941883006L, 839670817382L, 449645100883L, 908560915639L, 663635752753L, 686385596256L, 533307074436L, 485984573679L, 592999172735L, 85657885567L, 1044243502489L, 432987504590L, 196068770638L, 806115296137L, 435704648423L, 843193348602L, 328357917603L, 281623149375L, 477057405084L, 640377879862L, 657866426086L, 221544086210L, 1024739871751L, 350677353571L, 880575553347L, 981157900758L, 690121451496L, 574134426494L, 863893433107L, 1089402132982L, 624151939607L, 480085770768L, 349054615940L, 247661354595L, 367579197044L, 380319961659L, 190985835698L, 985101352153L, 41568168748L, 659633022353L, 861859025311L, 516536648985L, 201345895590L, 172347036043L, 978667996872L, 495126318635L, 1076534034345L, 372464613470L, 1045229949652L, 309618933482L, 294323331360L, 1076915857780L, 51610132169L, 863910910573L, 22439874095L, 574320922095L, 554819452685L, 844146240494L, 87730358308L, 676198373944L, 394268904675L, 1013828406506L, 860576572897L, 902489276669L, 134763921546L, 333972015814L, 848426717662L, 991547364712L, 1016250836673L, 786238248910L, 471227367373L, 945806905177L, 1095923034726L, 181886430902L, 69684581876L, 305254218595L, 925424430302L, 975312491656L, 540322406593L, 646031472106L, 209696551133L, 210909431801L, 827015348579L, 498982926029L, 981384795269L, 258201544797L, 474865220351L, 434702977920L, 942428123841L, 907817609748L, 169346288998L, 242517847780L, 952705857124L, 988382311122L, 471702514898L, 1037536546365L, 106012468834L, 722797159636L, 137273216204L, 417983385244L, 1096805158865L, 554443658153L, 900050996000L, 936943729032L, 820435345915L, 806147054380L, 432110673605L, 318311964767L, 799028233067L, 48068797727L, 961946591642L, 662496317685L, 176538626068L, 140712188221L, 685655699378L, 923144923617L, 321236383675L, 89516183955L, 460616917539L, 76593810370L, 722015386238L, 196793326960L, 596452706600L, 849737400831L, 112099213132L, 105857607610L, 22174740358L, 779156613505L, 37790748012L, 573945837600L, 487960165405L, 427259486985L, 955398714338L, 434012763172L, 56519702242L, 732674357428L, 105881257160L, 1023108511277L, 480790578626L, 243957428575L, 38759961602L, 901587808254L, 347198592246L, 604106780659L, 6338963757L, 302211232652L, 874615790648L, 340306661116L, 182301956461L, 623231571719L, 166619758132L, 301224746382L, 1056464148441L, 1071978008738L, 14083327688L, 752449401381L, 848405885893L, 664185053969L, 436973519073L, 1052597930151L, 850810197445L, 89908595397L, 757810346975L, 60481554074L, 1092185185604L, 400395306791L, 934688300433L, 387965298069L, 138399635742L, 412932396584L, 349002413387L, 39365920413L, 499532078946L, 658452028073L, 822826003396L, 762575674271L, 204969490796L, 128943738407L, 76266634333L, 25992496964L, 1097980840550L, 755489427485L, 463598317471L, 908533172755L, 1002135541281L, 364105401302L, 118099043518L, 50422552801L, 204983211522L, 231937776036L, 1022745304661L, 429800006538L, 904766191181L, 707078547447L, 547787135127L, 419934496043L, 7334894288L, 824973146735L, 591557795377L, 1031493528982L, 811461020154L, 962259651050L, 847997998474L, 1065945451891L, 47926570041L, 171060369949L, 249477073535L, 732399515548L, 875839876422L, 155961664154L, 1078303652441L, 727855004353L, 578156296059L, 458332187700L, 64674211880L, 1023545147136L, 1089460591481L, 160824124071L, 969009515126L, 952260977363L, 929642625744L, 327426790167L, 308635981558L, 946429955160L, 816439969102L, 645350616815L, 702054429181L, 885978826471L, 629560715336L, 1003787114006L, 479716501732L, 258733983817L, 28888495987L, 323452481266L, 471563477493L, 188108019862L, 956283876118L, 23731866811L, 666690310772L, 1035323086494L, 541201713548L, 779331756088L, 507796599L, 767620642353L, 1042216550021L, 487163681791L, 781601873050L, 425835064459L, 1081905374325L, 214839143649L, 285882586702L, 831580238468L, 229088952140L, 956520661026L, 966184836317L, 271901999873L, 603474606458L, 659089865662L, 531906076706L, 732920135416L, 973305026884L, 316269300841L, 5535127694L, 994853711075L, 1047882704331L, 960017688336L, 806601576392L, 881549677589L, 272983099649L, 916128727375L, 382569155262L, 192185165028L, 486575836758L, 5675583650L, 232252128867L, 643507561376L, 383191164368L, 161021156926L, 663922933455L, 549886492059L, 760176248358L, 396989917652L, 823209050576L, 287740960170L, 377688432639L, 955695592633L, 711147633391L, 257751833585L, 559161329331L, 1023516061559L, 23958512882L, 1003614517162L, 63010953226L, 976754784297L, 947169645767L, 219419369024L, 479160260181L, 376094740450L, 131378847942L, 971048234480L, 782143545994L, 88255114180L, 407231514051L, 1079765307708L, 998432004935L, 906206693605L, 24052532289L, 610602355228L, 607445695261L, 576256752170L, 584325952363L, 644296154837L, 592921763737L, 495317849881L, 162715205752L, 583453207764L, 311364414555L, 475983486077L, 373343228990L, 721281110791L, 811832245729L, 122721513029L, 693226404917L, 725800574437L, 1048811773597L, 500303736800L, 193203708108L, 252961491503L, 578073182199L, 349558561143L, 84404972515L, 428609152487L, 96956018783L, 175580507690L, 372154124230L, 247337911946L, 664874572468L, 152809012570L, 787283650569L, 30074376353L, 875318996140L, 435955818970L, 157857080545L, 346312472176L, 602734085003L, 597659852130L, 344156369511L, 527422940422L, 911699589010L, 250920695105L, 727541736002L, 503550741588L, 388236854868L, 178486180793L, 50833512163L, 766498129788L, 836077441224L, 528636409579L, 252560596463L, 1043062664894L, 651608560820L, 510978907897L, 551145290538L, 618200706276L, 200251754681L, 423763829355L, 320529291890L, 654644873214L, 984446939520L, 190893736395L, 48710970539L, 91921470892L, 732997549782L, 693038097483L, 556773546331L, 1086210522987L, 483360257762L, 529407968602L, 644358239901L, 474832870320L, 1067507093493L, 456551051524L, 708299302434L, 825049664055L, 260422145283L, 102737800319L, 877212977233L, 471833436788L, 996018710734L, 117595661552L, 798383120709L, 376662838057L, 431598703768L, 821971453058L, 187624537724L, 157960553185L, 228685145477L, 279850365969L, 1006633363073L, 624463892252L, 209665132804L, 57082377524L, 390246819371L, 264854838019L, 684812250669L, 821012067196L, 805171279694L, 267111724018L, 36935572654L, 709414265686L, 533858215991L, 740858005439L, 180605388959L, 609892528255L, 521521575744L, 446136473290L, 340549590398L, 517077153844L, 316718737618L, 1013115028394L, 873770481723L, 455814966633L, 285690160138L, 554152231375L, 571856001102L, 1042463615260L, 516933543205L, 967738128385L, 925998276533L, 311388957129L, 292994125193L, 769239546046L, 130607054043L, 150451938702L, 449894394545L, 573877708954L, 277028664758L, 878661967334L, 882260535017L, 796571969475L, 642072279745L, 456869335842L, 256492743564L, 283140173661L, 333341327546L, 471183817186L, 676061674420L, 313946455051L, 464232858795L, 623497185451L, 137860713934L, 861507251208L, 872519115379L, 186070414099L, 418308547874L, 260110909055L, 724862953453L, 313592762080L, 827836298336L, 538922392334L, 147878462234L, 1061445921768L, 1091298395725L, 512579678035L, 588497641890L, 900081400255L, 888567578781L, 317007982935L, 92134563239L, 775391549959L, 655150672521L, 543990297488L, 621811943369L, 917735930614L, 623221016735L, 1061832413973L, 581584081208L, 303307601066L, 166173004439L, 924386413406L, 972078944745L, 975241888096L, 619605717895L, 237662168648L, 930806034661L, 834941356113L, 596338632534L, 999570905287L, 891646211233L, 535054718978L, 914812020961L, 818179431338L, 980853426972L, 504751726497L, 578558079796L, 223767418393L, 425124701989L, 158066770247L, 41049552134L, 411100940518L, 628826345730L, 278562837592L, 439993735000L, 1091186832882L, 1070085341315L, 103345514768L, 650837151768L, 144440958819L, 160207118222L, 183887907855L, 803978568606L, 754923976104L, 443946937680L, 664789582098L, 56723108838L, 938555879025L, 234188034668L, 646656019799L, 260948400268L, 610176785685L, 670934971415L, 121857770134L, 437837327695L, 264561326267L, 280239054307L, 542574105449L, 867442652846L, 781954996898L, 327692293249L, 90346112595L, 920041621779L, 685756581724L, 1029417745779L, 367261571607L, 515085981782L, 642959661920L, 991616659982L, 393922446845L, 706929089904L, 1041989104633L, 58177276489L, 188286580651L, 651713852133L, 595732301353L, 756853261816L, 706378984488L, 846323120395L, 783308780616L, 573899104016L, 329404079969L, 110710343444L, 35970548208L, 2494669332L, 158396980202L, 717387504908L, 240413749122L, 750049967885L, 748273592963L, 662101533139L, 105370338044L, 508784463614L, 693084038402L, 745664740239L, 1041975760195L, 17915455005L, 361141074242L, 604010996411L, 317803728473L, 208768241778L, 236122899084L, 886451718793L, 692918043687L, 466625139761L, 1033771423825L, 1005167214554L, 1017935830495L, 581342941473L, 440338178121L, 563595587087L, 98852607530L, 335723936008L, 1019444341870L, 254735285605L, 975286631288L, 468078166391L, 966424955790L, 103896116130L, 1031899784945L, 742373571844L, 425879616232L, 277725872463L, 1060017560488L, 880289290255L, 354677818173L, 155950649517L, 111997521029L, 744373261966L, 36020473149L, 971193436624L, 1063041210705L, 70945275206L, 812809079419L, 670598514766L, 113291168230L, 738303736812L, 451460167238L, 986790484539L, 92430557268L, 160937582215L, 716520884769L, 589646547506L, 412640254901L, 840462566442L, 20025767419L, 802789713277L, 880416803734L, 989276840684L, 487781380431L, 13017750977L, 393224048595L, 48612739437L, 640942500304L, 425525426958L, 906048721259L, 284739402981L, 742887162951L, 297226229078L, 529725736559L, 863420521L, 942468061145L, 774141558174L, 40672402963L, 440327709569L, 138808238251L, 540461724712L, 1039267523761L, 613377075975L, 894555152152L, 852669809223L, 1005681738198L, 358278394070L, 280484049254L, 1011060059863L, 188682734575L, 245638984585L, 92288547289L, 598000386105L, 610531705321L, 14552178532L, 1041396677435L, 28122840879L, 421587780128L, 67546399195L, 570832842880L, 1027731095113L, 388965508632L, 391541719480L, 157514963607L, 632369619524L, 972642059476L, 1090172663041L, 902088537647L, 1039981994325L, 232026797133L, 710298906320L, 189578324772L, 554405632248L, 323980175728L, 560642113124L, 224097638503L, 1006397582184L, 540512665937L, 771701644899L, 85075105301L, 712366749717L, 270398214597L, 1042486403375L, 85874882800L, 469244024193L, 340359759988L, 881064226154L, 360776234268L, 583983794500L, 659476334260L, 1040920049993L, 837220865977L, 240341158493L, 512350413309L, 1011663580091L, 868002366724L, 659160046034L, 398656544672L, 10401940571L, 584222359414L, 640001091592L, 209538424371L, 937053161078L, 84349637021L, 982846786261L, 1078203495056L, 497473612030L, 1083191760127L, 288805225024L, 936074825308L, 55682365340L, 412585985341L, 867425043205L, 591247214245L, 1038007331036L, 590943266248L, 760159003677L, 738991303244L, 1656262919L, 168268329985L, 379010006707L, 670517227264L, 549824914887L, 86332957438L, 665977950064L, 1062596368041L, 133890326131L, 1058664460790L, 427788347668L, 420011007615L, 253136932475L, 999555005673L, 668203168918L, 551163895999L, 6739901358L, 784503165121L, 580952107849L, 524948105002L, 970999373271L, 900771644989L, 1071067331611L, 727488740527L, 809504722005L, 337154183214L, 80117492637L, 728600757183L, 264606334267L, 1047821708418L, 811883499060L, 415461692010L, 615058598286L, 906472589014L, 330193067055L, 594954876045L, 326988435469L, 568533840838L, 52296786119L, 1075156236460L, 65592668529L, 880472823294L, 925313496725L, 53193051949L, 384794506844L, 1082826268226L, 156419004917L, 967756174935L, 46140260816L, 1078910713261L, 779593202961L, 553006046658L, 161122593276L, 725482838239L, 486070745504L, 819242245248L, 1076941970409L, 802906223341L, 105679135552L, 960156382663L, 185391145089L, 368254551773L, 769744350646L, 42680114795L, 1070234948415L, 787153480911L, 631647657006L, 313346376029L, 506670028268L, 245803310699L, 680147397465L, 150308479986L, 525819227055L, 328312844382L, 62131712250L, 140296805351L, 54880048096L, 190343638760L, 530064507890L, 487446728960L, 539258010071L, 612116705572L, 859074354135L, 490325670826L, 788894780646L, 11900614099L, 288202744434L, 283447152700L, 803616655318L, 829160029904L, 259376802726L, 88047883360L, 655224742985L, 852287144099L, 226071301978L, 1025197613718L, 864693434600L, 246019207271L, 337456380024L, 422370354416L, 449509491547L, 82187076445L, 795707507107L, 232501013853L, 550307701280L, 689591986370L, 76876963502L, 232362200805L, 11130022200L, 588843936927L, 560832194188L, 264616215750L, 254374647483L, 474102575478L, 926913227214L, 663335968002L, 522456275323L, 406473359594L, 344768074605L, 74665414433L, 348150102761L, 950603958618L, 171316946780L, 828169095105L, 134140140250L, 302983910581L, 702836605567L, 426153799511L, 247170362488L, 246990940816L, 227655939816L, 377073295422L, 1097921104040L, 867849575880L, 735022038352L, 1055759307074L, 204387879629L, 10096208397L, 200507586221L, 682402832834L, 524343863470L, 357440085654L, 645062955487L, 1063256979508L, 760761420365L, 550323732793L, 349633318582L, 369739853515L, 366774865302L, 157023610830L, 463497350018L, 414106888640L, 169692841009L, 855393256055L, 367539093666L, 272477285672L, 556743172690L, 48964611612L, 402632589381L, 1073310118690L, 682800880431L, 625301602783L, 222617942429L, 660176807032L, 832011139133L, 356633846865L, 760326581076L, 414570508644L, 970874659111L, 711879829302L, 245814511761L, 693502485048L, 587103030919L, 362690681654L, 35858483558L, 426469392136L, 439991977666L, 110773229997L, 149346366243L, 788598238248L, 247709017360L, 734811053325L, 335780371941L, 629413816111L, 343467137814L, 435332560976L, 243176591874L, 852214851700L, 155270620352L, 104933061489L, 779994165803L, 175383994164L, 351208284098L, 661319232437L, 471211266830L, 323892625932L, 435042220467L, 148586636554L, 785664483663L, 618792180089L, 601443386223L, 156542402811L, 471455130140L, 27745094051L, 454610202211L, 454721576848L, 73080049309L, 465058062894L, 13435666660L, 273771405083L, 129899978896L, 68105205073L, 851272669025L, 363434533063L, 819665672766L, 850686005591L, 208379499807L, 401975647718L, 1027035519097L, 551702477808L, 802928722511L, 989104666537L, 908410490949L, 451380983034L, 1009398922516L, 292358178575L, 350062373360L, 562659529565L, 681179910092L, 553368439931L, 219428216647L, 1078659507202L, 920588062509L, 820456369364L, 831745823599L, 1048916338519L, 681541916575L, 986615657622L, 787337372734L, 903455615361L, 1022288333608L, 696379788847L, 308476710652L, 518452168099L, 172421587355L, 267432394200L, 565863333635L, 634642480828L, 1090758691577L, 958930044025L, 37413614735L, 184147890569L, 382498750452L, 167873280301L, 117053562855L, 30658672092L, 522695721013L, 185541418708L, 356249212768L, 930721631978L, 133295150600L, 523502273014L, 110123760775L, 487716195125L, 322712797709L, 784302228580L, 897931201752L, 266163527464L, 947914585815L, 957270308630L, 133292095574L, 4159819002L, 64867023204L, 127986614883L, 859019356139L, 508679247587L, 224122822694L, 693188906698L, 445961901467L, 340620559826L, 124988815442L, 452310869718L, 732449693982L, 3802608760L, 1053514126967L, 737858164726L, 620311916924L, 1091295870911L, 992955663541L, 801423778844L, 972815821563L, 349436962671L, 923087505933L, 22435029900L, 461480926226L, 971417705254L, 757949059006L, 814249123606L, 1017248369762L, 89826030613L, 1043906434982L, 53713250860L, 351767490554L, 858282335066L, 156683822584L, 743951394349L, 1091806141940L, 308970846437L, 561584554827L, 672879672872L, 606537089024L, 755792759420L, 255085654582L, 871834291002L, 969410626461L, 428431799575L, 770626058532L, 811245508848L, 394760743308L, 288080636807L, 654722902960L, 670047118554L, 401717180305L, 374437263381L, 391459153556L, 841662727085L, 1094197844707L, 758142231027L, 124230478775L, 132342934887L, 735915587671L, 491275522630L, 671090778611L, 943165151799L, 659377744455L, 478411219889L, 224274140984L, 619426908238L, 728633349060L, 798853022011L, 814850803459L, 1067842667060L, 465794987096L, 579085852875L, 87401994414L, 424664762192L, 893585503494L, 770804302097L, 83738985925L, 704895899789L, 429229280577L, 663369877602L, 618294272721L, 852084934750L, 1059578391719L, 807937746153L, 380535008098L, 850585333347L, 177924576654L, 932940928039L, 936620846438L, 290112574820L, 750661894357L, 187828008777L, 117411895853L, 1075504521270L, 1036675350200L, 482854776365L, 162246138227L, 491990446097L, 78532368094L, 533407385221L, 977418983151L, 91633033360L, 349309812668L, 604380274353L, 795143375723L, 774130557887L, 451522556071L, 602241625028L, 2056059687L, 321050458392L, 532514943854L, 726755710482L, 864641897064L, 654611313254L, 605379650675L, 2686021370L, 249204037745L, 606949119088L, 534008239943L, 185439688054L, 1037478447347L, 344460835513L, 674573999374L, 164103471334L, 893469026169L, 767016490156L, 719425130723L, 780223539460L, 712889483129L, 701376934049L, 492132242790L, 119370762431L, 936913063241L, 447144285961L, 445174642871L, 226476418788L, 1035650436912L, 601618344973L, 422345611917L, 30738889740L, 450016600281L, 983262988043L, 340306933564L, 790250876691L, 752489979387L, 763981189146L, 747454107595L, 926078260427L, 855364996087L, 148432018512L, 555985320115L, 1092749982914L, 114903933831L, 834701705025L, 359682425569L, 731305862930L, 736491657653L, 767881447661L, 532332823042L, 137651705662L, 894579380961L, 859633630992L, 994487936236L, 69573179838L, 497768870470L, 406488708059L, 589902875946L, 287323183894L, 258729497177L, 715164512231L, 863064660949L, 538754871964L, 94129021970L, 248101350283L, 661930028701L, 34765813172L, 200778905069L, 771173436335L, 357557090319L, 181286777375L, 713354365976L, 651943227846L, 831600534132L, 162974043714L, 32254079910L, 222964314902L, 484466812613L, 805047263927L, 988162877207L, 1024331355994L, 116523094577L, 1077218628825L, 967851665566L, 651921040696L, 582307528403L, 127888229647L, 1079595597742L, 429141975409L, 199092807735L, 664129324754L, 310669593449L, 797455631656L, 856307584490L, 566699078205L, 316364673006L, 778812749870L, 393034192637L, 364798809727L, 1060717402148L, 1060443605784L, 1083212266521L, 891158674949L}
//        ;
//        publicKey.data().getDynArray().setData(data);

        // set the parmsId
        // todo: really need deep-copy?
        publicKey.setParmsId(contextData.getParmsId().clone());
    }

//    /**
//     * @param newKey      single poly in RNS, length is k * N
//     * @param destination
//     * @param saveSeed
//     */
//    private void generateOneKeySwitchKey(long[] newKey, PublicKey[] destination, boolean saveSeed) {
//
//
//        if (!context.isUsingKeySwitching()) {
//            throw new IllegalArgumentException("keyswitching is not supported by the context");
//        }
//
//        int coeffCount = context.keyContextData().getParms().getPolyModulusDegree();
//        int decomposeModCount = context.firstContextData().getParms().getCoeffModulus().length;
//        Context.ContextData keyContextData = context.keyContextData();
//        EncryptionParams keyParms = keyContextData.getParms();
//        Modulus[] keyModulus = keyParms.getCoeffModulus();
//        // todo: really need this check?
//        if (!Common.productFitsIn(false, coeffCount, decomposeModCount)) {
//            throw new IllegalArgumentException("invalid parameters");
//        }
//
//        assert destination.length >= decomposeModCount;
//        // 这里面是比较耗时的操作，所以考虑并发
//        IntStream.range(0, decomposeModCount).parallel().forEach(
//                i -> {
//                    long[] temp = new long[coeffCount];
//
//                    RingLwe.encryptZeroSymmetric(
//                            secretKey,
//                            context,
//                            keyContextData.getParmsId(),
//                            true,
//                            saveSeed,
//                            destination[i].data()
//                    );
//
//                    long factor = UintArithmeticSmallMod.barrettReduce64(keyModulus[keyModulus.length - 1].getValue(), keyModulus[i]);
//
//                    PolyArithmeticSmallMod.multiplyPolyScalarCoeffMod(
//                            newKey, i * coeffCount, coeffCount, factor, keyModulus[i], 0, temp
//                    );
//
//                    // We use the SeqIter at get<3>(I) to find the i-th RNS factor of the first destination polynomial.
//
//                    // destination[i].data() 是 Ciphertext, .getData() 是 Ciphertext 的底层数组，可认为是 multi-poly in RNS, size * k * N
//                    PolyArithmeticSmallMod.addPolyCoeffMod(destination[i].data().getData(), 0, temp, 0, coeffCount, keyModulus[i], 0, destination[i].data().getData());
//                }
//        );
//    }


//    /**
//     * @param newKeys     multi-poly in RNS (polyIter), length is size * k * N
//     * @param startIndex  startIndex of the RnsIter used in newKeys
//     * @param destination
//     * @param saveSeed
//     */
//    private void generateOneKeySwitchKey(long[] newKeys, int startIndex, PublicKey[] destination, boolean saveSeed) {
//
//        if (!context.isUsingKeySwitching()) {
//            throw new IllegalArgumentException("key switching is not supported by the context");
//        }
//
//        int coeffCount = context.keyContextData().getParms().getPolyModulusDegree();
//        int decomposeModCount = context.firstContextData().getParms().getCoeffModulus().length;
//        Context.ContextData keyContextData = context.keyContextData();
//        EncryptionParams keyParms = keyContextData.getParms();
//        Modulus[] keyModulus = keyParms.getCoeffModulus();
//        // todo: really need this check?
//        if (!Common.productFitsIn(false, coeffCount, decomposeModCount)) {
//            throw new IllegalArgumentException("invalid parameters");
//        }
//        // 实例化 destination
//        // 这里的 destination 是一个 null 的 PublicKey[], 在这里实例化，无法影响到外层，所以又重写了一个重载函数
//
//
//        assert destination.length >= decomposeModCount;
//        // 这里面是比较耗时的操作，所以考虑并发
//        IntStream.range(0, decomposeModCount).parallel().forEach(
//                i -> {
//                    long[] temp = new long[coeffCount];
//
//                    RingLwe.encryptZeroSymmetric(
//                            secretKey,
//                            context,
//                            keyContextData.getParmsId(),
//                            true,
//                            saveSeed,
//                            destination[i].data()
//                    );
//
//                    long factor = UintArithmeticSmallMod.barrettReduce64(keyModulus[keyModulus.length - 1].getValue(), keyModulus[i]);
//
//                    PolyArithmeticSmallMod.multiplyPolyScalarCoeffMod(
//                            newKeys, startIndex + i * coeffCount, coeffCount, factor, keyModulus[i], 0, temp
//                    );
//
//                    // We use the SeqIter at get<3>(I) to find the i-th RNS factor of the first destination polynomial.
//
//                    // destination[i].data() 是 Ciphertext, .getData() 是 Ciphertext 的底层数组，可认为是 multi-poly in RNS, size * k * N
//                    PolyArithmeticSmallMod.addPolyCoeffMod(destination[i].data().getData(), 0, temp, 0, coeffCount, keyModulus[i], 0, destination[i].data().getData());
//                }
//        );
//    }

    private void generateOneKeySwitchKey(long[] newKeys, PublicKey[][] destinations, int destinationIndex, boolean saveSeed) {

        if (!context.isUsingKeySwitching()) {
            throw new IllegalArgumentException("key switching is not supported by the context");
        }

        int coeffCount = context.keyContextData().getParms().getPolyModulusDegree();
        int decomposeModCount = context.firstContextData().getParms().getCoeffModulus().length;
        Context.ContextData keyContextData = context.keyContextData();
        EncryptionParams keyParms = keyContextData.getParms();
        Modulus[] keyModulus = keyParms.getCoeffModulus();
        // todo: really need this check?
        if (!Common.productFitsIn(false, coeffCount, decomposeModCount)) {
            throw new IllegalArgumentException("invalid parameters");
        }
        // 实例化 destination
        // 通过 二维数组的 index 去实例化，可以影响到调用函数外的 destinations
        // 这里就是实例化了长度为 new PublicKey[decomposeModCount]
        destinations[destinationIndex] = IntStream.range(0, decomposeModCount)
                .mapToObj(i -> new PublicKey()).toArray(PublicKey[]::new);

        // 这里面是比较耗时的操作，所以考虑并发
        IntStream.range(0, decomposeModCount).parallel().forEach(
                i -> {
                    long[] temp = new long[coeffCount];

                    RingLwe.encryptZeroSymmetric(
                            secretKey,
                            context,
                            keyContextData.getParmsId(),
                            true,
                            saveSeed,
                            destinations[destinationIndex][i].data()
                    );

                    long factor = UintArithmeticSmallMod.barrettReduce64(keyModulus[keyModulus.length - 1].getValue(), keyModulus[i]);

                    PolyArithmeticSmallMod.multiplyPolyScalarCoeffMod(
                            newKeys,
                            i * coeffCount,
                            coeffCount,
                            factor,
                            keyModulus[i],
                            0,
                            temp
                    );

                    // We use the SeqIter at get<3>(I) to find the i-th RNS factor of the first destination polynomial.

                    // destination[i].data() 是 Ciphertext, .getData() 是 Ciphertext 的底层数组，可认为是 multi-poly in RNS, size * k * N
                    PolyArithmeticSmallMod.addPolyCoeffMod(
                            destinations[destinationIndex][i].data().getData(),
                            i * coeffCount,
                            temp,
                            0,
                            coeffCount,
                            keyModulus[i],
                            i * coeffCount,
                            destinations[destinationIndex][i].data().getData());
                }
        );
    }

    /**
     * 注意函数签名，是为了处理 destinations[destinationIndex]
     *
     * @param newKeys          + startIndex =  RnsIter, length is k * N
     * @param startIndex
     * @param destinations
     * @param destinationIndex
     * @param saveSeed
     */
    private void generateOneKeySwitchKey(long[] newKeys, int startIndex, PublicKey[][] destinations, int destinationIndex, boolean saveSeed) {

        if (!context.isUsingKeySwitching()) {
            throw new IllegalArgumentException("key switching is not supported by the context");
        }

        int coeffCount = context.keyContextData().getParms().getPolyModulusDegree();
        int decomposeModCount = context.firstContextData().getParms().getCoeffModulus().length;
        Context.ContextData keyContextData = context.keyContextData();
        EncryptionParams keyParms = keyContextData.getParms();
        Modulus[] keyModulus = keyParms.getCoeffModulus();
        // todo: really need this check?
        if (!Common.productFitsIn(false, coeffCount, decomposeModCount)) {
            throw new IllegalArgumentException("invalid parameters");
        }
        // 实例化 destination
        // 通过 二维数组的 index 去实例化，可以影响到调用函数外的 destinations
        // 这里就是实例化了长度为 new PublicKey[decomposeModCount]
        destinations[destinationIndex] = IntStream.range(0, decomposeModCount)
                .mapToObj(i -> new PublicKey()).toArray(PublicKey[]::new);


        // 这里面是比较耗时的操作，所以考虑并发
        IntStream.range(0, decomposeModCount).parallel().forEach(
                i -> {
                    long[] temp = new long[coeffCount];

                    RingLwe.encryptZeroSymmetric(
                            secretKey,
                            context,
                            keyContextData.getParmsId(),
                            true,
                            saveSeed,
                            destinations[destinationIndex][i].data()
                    );

                    long factor = UintArithmeticSmallMod.barrettReduce64(keyModulus[keyModulus.length - 1].getValue(), keyModulus[i]);
//                    System.out.println("i: " + i + ", startIndex + i * coeffCount: " + startIndex + i * coeffCount);

                    PolyArithmeticSmallMod.multiplyPolyScalarCoeffMod(
                            newKeys, startIndex + i * coeffCount, coeffCount, factor, keyModulus[i], 0, temp
                    );

                    // We use the SeqIter at get<3>(I) to find the i-th RNS factor of the first destination polynomial.

                    // destination[i].data() 是 Ciphertext, .getData() 是 Ciphertext 的底层数组，
                    // 可认为是 multi-poly in RNS, size * k * N
                    // 注意第二个参数，index 的计算，这里的逻辑有点复杂
                    // size * k * N , 这里不管是哪一个 密文 （destinations[destinationIndex][i].data().getData()）
                    // 都取 第 0 个 k * N , 然后在 k * N 里，取 第 i/k 个, 一个具体的例子
                    // i = 0 --> c0 (size * k * N ) --> c0[0] --> [0, k * N) ---> c0[0][i] --> c0[0][0] --> [0, N)
                    // i = 1 --->c1 (size * k * N ) ---> c1[0] ---> [0, k * N) ---> c1[0][i] --> c0[0][1] --> [N, 2N)
                    PolyArithmeticSmallMod.addPolyCoeffMod(
                            destinations[destinationIndex][i].data().getData(),
                            i * coeffCount,
                            temp,
                            0,
                            coeffCount,
                            keyModulus[i],
                            i * coeffCount,
                            destinations[destinationIndex][i].data().getData());
                }
        );

    }


    /**
     * @param newKeys            polyIter, size * k * N
     * @param newKeysCoeffCount  N
     * @param newKeysModulusSize k, 为了避免使用 PolyIter 对象带来的额外开销， 使用 long[] + k + N 来等价表示 PolyIter
     * @param numKeys
     * @param destination
     * @param saveSeed
     */
    private void generateKeySwitchKeys(long[] newKeys, int newKeysCoeffCount, int newKeysModulusSize, int numKeys, KeySwitchKeys destination, boolean saveSeed) {


        int coeffCount = context.keyContextData().getParms().getPolyModulusDegree();
        Context.ContextData keyContextData = context.keyContextData();
        EncryptionParams keyParms = keyContextData.getParms();
        int coeffModulusSize = keyParms.getCoeffModulus().length;


        // size check
        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize, numKeys)) {
            throw new IllegalArgumentException("invalid parameters");
        }

        assert newKeysCoeffCount == coeffCount;
        assert newKeysModulusSize == coeffModulusSize;

        // destination本质上是 PublicKey[][], 之前new的时候还没有初始化这个数组，这里需要补上
//        int decomposeModCount = context.firstContextData().getParms().getCoeffModulus().length;
        destination.resizeRows(numKeys);

        // 注意起点的计算
//        IntStream.range(0, numKeys).parallel().forEach(
//                i -> generateOneKeySwitchKey(newKeys, i * coeffCount * coeffModulusSize, destination.data()[i], saveSeed)
//        );

        // 注意这个被调用的函数签名
        IntStream.range(0, numKeys).parallel().forEach(
                i -> generateOneKeySwitchKey(newKeys, i * coeffCount * coeffModulusSize, destination.data(), i, saveSeed)
        );

    }


    /**
     * @param newKeys            polyIter, size * k * N
     * @param startIndex         newKeysPolyIter + startIndex = newKeysRnsIter
     * @param newKeysCoeffCount  k
     * @param newKeysModulusSize N
     * @param numKeys
     * @param destination
     * @param saveSeed
     */
    private void generateKeySwitchKeys(long[] newKeys, int startIndex, int newKeysCoeffCount, int newKeysModulusSize, int numKeys, KeySwitchKeys destination, boolean saveSeed) {

        assert startIndex % (newKeysCoeffCount * newKeysModulusSize) == 0;

        int coeffCount = context.keyContextData().getParms().getPolyModulusDegree();
        Context.ContextData keyContextData = context.keyContextData();
        EncryptionParams keyParms = keyContextData.getParms();
        int coeffModulusSize = keyParms.getCoeffModulus().length;

        // size check
        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize, numKeys)) {
            throw new IllegalArgumentException("invalid parameters");
        }

        assert newKeysCoeffCount == coeffCount;
        assert newKeysModulusSize == coeffModulusSize;

        destination.resizeRows(numKeys);

        // 注意起点的计算
        IntStream.range(0, numKeys).parallel().forEach(
                i -> generateOneKeySwitchKey(newKeys, startIndex + i * coeffCount * coeffModulusSize, destination.data(), i, saveSeed)
        );
    }


    private void createRelinKeys(int count, boolean saveSeed, RelinKeys destination) {

        if (!skGenerated) {
            throw new IllegalArgumentException("cannot generate relinearization keys for unspecified secret key");
        }
        // count 是 密文中多项式的数量
        if (count == 0 || count > Constants.CIPHERTEXT_SIZE_MAX - 2) {
            throw new IllegalArgumentException("invalid count");
        }

        // Extract encryption parameters.
        Context.ContextData contextData = context.keyContextData();
        EncryptionParams parms = contextData.getParms();
        int coeffCount = parms.getPolyModulusDegree();
        int coeffModulusSize = parms.getCoeffModulus().length;

        // todo: really need check?
        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize)) {
            throw new IllegalArgumentException("invalid parameters");
        }

        // Make sure we have enough secret keys computed
        // 计算 sk sk^2, ..., sk^{count+1}
        computeSecretKeyArray(contextData, count + 1);

        // Assume the secret key is already transformed into NTT form.
//        RelinKeys relinKeys = new RelinKeys();
//        System.out.println("secretKeyArray: " + secretKeyArray.length);
        // 开始计算 KeySwitchKeys
        // 注意第二个参数是 secretKeyArray 的起点
        generateKeySwitchKeys(secretKeyArray,
                coeffCount * coeffModulusSize,
                coeffCount,
                coeffModulusSize,
                count,
                (KeySwitchKeys) destination,
                saveSeed
        );
        // todo: really need deep-copy?
        destination.setParmsId(contextData.getParmsId().clone());

    }

    /**
     * Generates and returns the specified number of relinearization keys.
     *
     * @param count    The number of relinearization keys to generate
     * @param saveSeed If true, save seed instead of a polynomial.
     * @return
     */
    private RelinKeys createRelinKeys(int count, boolean saveSeed) {

        if (!skGenerated) {
            throw new IllegalArgumentException("cannot generate relinearization keys for unspecified secret key");
        }

        if (count == 0 || count > Constants.CIPHERTEXT_SIZE_MAX - 2) {
            throw new IllegalArgumentException("invalid count");
        }

        // Extract encryption parameters.
        Context.ContextData contextData = context.keyContextData();
        EncryptionParams parms = contextData.getParms();
        int coeffCount = parms.getPolyModulusDegree();
        int coeffModulusSize = parms.getCoeffModulus().length;

        // todo: really need check?
        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize)) {
            throw new IllegalArgumentException("invalid parameters");
        }

        // Make sure we have enough secret keys computed
        computeSecretKeyArray(contextData, count + 1);

        // Assume the secret key is already transformed into NTT form.
        RelinKeys relinKeys = new RelinKeys();

        generateKeySwitchKeys(secretKeyArray,
                coeffCount * coeffModulusSize,
                coeffCount,
                coeffModulusSize,
                coeffCount,
                (KeySwitchKeys) relinKeys,
                saveSeed
        );
        // todo: really need deep-copy?
        relinKeys.setParmsId(contextData.getParmsId().clone());

        return relinKeys;
    }

    private void createGaloisKeys(int[] galoisElts, boolean saveSeed, GaloisKeys destination) {
        if (!skGenerated) {
            throw new IllegalArgumentException("cannot generate Galois keys for unspecified secret key");
        }

        Context.ContextData contextData = context.keyContextData();
        EncryptionParams parms = contextData.getParms();
        Modulus[] coeffModulus = parms.getCoeffModulus();
        GaloisTool galoisTool = contextData.getGaloisTool();
        int coeffCount = parms.getPolyModulusDegree();
        int coeffModulusSize = coeffModulus.length;

        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize, 2)) {
            throw new IllegalArgumentException("invalid parameters");
        }

//        GaloisKeys galoisKeys = new GaloisKeys();
        // The max number of keys is equal to number of coefficients
//        destination.resize(coeffCount, decomposeModCount);
        destination.resizeRows(coeffCount);
        for (int galoisElt : galoisElts) {

//            System.out.println("galoisElt: " + galoisElt);


            // Verify coprime conditions.
            // 最低位为0, 则一定是偶数
            if ((galoisElt & 1) == 0 || (galoisElt >= coeffCount << 1)) {
                throw new IllegalArgumentException("Galois element is not valid");
            }
            // Do we already have the key?
            if (destination.hasKey(galoisElt)) {
                continue;
            }
            // Rotate secret key for each coeff_modulus
            long[] rotatedSecretKey = new long[coeffModulusSize * coeffCount];
            galoisTool.applyGaloisNttRnsIter(secretKey.data().getData(), coeffCount, coeffModulusSize, galoisElt, rotatedSecretKey, coeffCount);

            // Initialize Galois key
            // This is the location in the galois_keys vector
            int index = GaloisKeys.getIndex(galoisElt);

            // Create Galois keys.
            // 注意这里是把整个 二维数组 PublicKey[][] 传进去，然后用 index 来指定哪一行
            generateOneKeySwitchKey(rotatedSecretKey, destination.data(), index, saveSeed);

//            generateOneKeySwitchKey(rotatedSecretKey, destination.data(index), saveSeed);
        }

        // Set the parmsId
        destination.setParmsId(contextData.getParmsId().clone());

    }

    private GaloisKeys createGaloisKeys(int[] galoisElts, boolean saveSeed) {
        if (!skGenerated) {
            throw new IllegalArgumentException("cannot generate Galois keys for unspecified secret key");
        }

        Context.ContextData contextData = context.keyContextData();
        EncryptionParams parms = contextData.getParms();
        Modulus[] coeffModulus = parms.getCoeffModulus();
        GaloisTool galoisTool = contextData.getGaloisTool();
        int coeffCount = parms.getPolyModulusDegree();
        int coeffModulusSize = coeffModulus.length;

        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize, 2)) {
            throw new IllegalArgumentException("invalid parameters");
        }

        GaloisKeys galoisKeys = new GaloisKeys();
//        int decomposeModCount = context.firstContextData().getParms().getCoeffModulus().length;
        // The max number of keys is equal to number of coefficients
//        galoisKeys.resize(coeffCount, decomposeModCount);
        galoisKeys.resizeRows(coeffCount);

        for (int galoisElt : galoisElts) {

//            System.out.println("galoisElt: " + galoisElt);
            // Verify coprime conditions.
            // 最低位为0, 则一定是偶数
            if ((galoisElt & 1) == 0 || (galoisElt >= (coeffCount << 1))) {
                throw new IllegalArgumentException("Galois element is not valid");
            }
            // Do we already have the key?
            if (galoisKeys.hasKey(galoisElt)) {
                continue;
            }
            // Rotate secret key for each coeff_modulus
            long[] rotatedSecretKey = new long[coeffModulusSize * coeffCount];
            galoisTool.applyGaloisNttRnsIter(secretKey.data().getData(), coeffCount, coeffModulusSize, galoisElt, rotatedSecretKey, coeffCount);

            // Initialize Galois key
            // This is the location in the galois_keys vector
            int index = GaloisKeys.getIndex(galoisElt);

            // Create Galois keys.
            // 一定要注意 galoisKeys.data(index) 和 galoisKeys.data()[index] 是不同的语义
            generateOneKeySwitchKey(rotatedSecretKey, galoisKeys.data(), index, saveSeed);
        }

        // Set the parmsId
        galoisKeys.setParmsId(contextData.getParmsId().clone());

        return galoisKeys;
    }


    private void computeSecretKeyArray(Context.ContextData contextData, int maxPower) {

        assert maxPower >= 1;
        assert (secretKeyArraySize > 0 && secretKeyArray != null);

        EncryptionParams parms = contextData.getParms();
        Modulus[] coeffModulus = parms.getCoeffModulus();
        int coeffCount = parms.getPolyModulusDegree();
        int coeffModulusSize = coeffModulus.length;

        // size check
        // todo: really need?
        if (!Common.productFitsIn(false, coeffCount, coeffModulusSize, maxPower)) {
            throw new IllegalArgumentException("invalid parameter");
        }

        int oldSize = secretKeyArraySize;
        int newSize = Math.max(oldSize, maxPower);
        if (oldSize == newSize) {
            return;
        }
        // Need to extend the array
        // Compute powers of secret key until max_power

        // 分配足够大的长度
        long[] newSecretKeyArray = new long[newSize * coeffCount * coeffModulusSize];
        // 先拷贝 old this.secretKeyArray 中的数据
        System.arraycopy(this.secretKeyArray, 0, newSecretKeyArray, 0, oldSize * coeffCount * coeffModulusSize);

        // Since all of the key powers in secret_key_array_ are already NTT transformed, to get the next one we simply
        // need to compute a dyadic product of the last one with the first one [which is equal to NTT(secret_key_)].
        // 计算 sk^1 sk^2 sk^3 ....
        // 计算逻辑是 sk^2 = sk * sk,  sk^3 = sk^2 * sk

        // 注意 i 的起点
        // secretKeyArray: [0, 1 * k * N), [1*k*N, 2*k*N), ..., [(oldSize - 1) * k * N , oldSize * k * N)
        // newSecretKeyArray: [0, 1 * k * N), [1*k*N, 2*k*N), ..., [(oldSize - 1) * k * N , oldSize * k * N),...,[(newSize - 1) * k * N , newSize * k * N)
        // 现在的计算逻辑是这样：newSecretKeyArray[ oldSize * k * N , (oldSize + 1) * k * N ) = newSecretKeyArray[(oldSize - 1) * k * N , oldSize * k * N) *  secretKeyArray[(oldSize - 1) * k * N , oldSize * k * N)
        // 注意 第二项的起点 是不变的

        int oldStartIndex = (oldSize - 1) * coeffCount * coeffModulusSize;
        // 注意到这里是没办法并发的，后一个计算结果 依赖于 前一个计算结果
        for (int i = oldSize - 1; i < oldSize - 1 + newSize - oldSize; i++) {

            int newStartIndex = i * coeffCount * coeffModulusSize;
            int newStartIndexPlusOne = (i + 1) * coeffCount * coeffModulusSize;

            PolyArithmeticSmallMod.dyadicProductCoeffModRnsIter(
                    newSecretKeyArray,
                    newStartIndex,
                    secretKeyArray,
                    oldStartIndex,
                    coeffModulusSize,
                    coeffCount,
                    coeffModulus,
                    newStartIndexPlusOne,
                    newSecretKeyArray
            );
        }


        // Do we still need to update size?
//        oldSize = secretKeyArraySize;
//        newSize = Math.max(oldSize, maxPower);
//        if (oldSize == newSize) {
//            return;
//        }
        // update size and array
        secretKeyArraySize = newSize;
        secretKeyArray = newSecretKeyArray;
    }


}
