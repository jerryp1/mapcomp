package edu.alibaba.mpc4j.crypto.fhe.utils;import edu.alibaba.mpc4j.common.tool.CommonConstants;import java.math.BigInteger;/** * @author Qixian Zhou * @date 2023/7/13 */public class CrtContext {    public int numPrimes;    public int primeSize;    public int polyModulusDegree;    public long[] primes;    public BigInteger modulus;    public NttContext[] nttContexts;    public BigInteger[] crtValues;    public long[] crtInvValues;    public CrtContext(int numPrimes, int primeSize, int polyModulusDegree) {        this.polyModulusDegree = polyModulusDegree;        this.numPrimes = numPrimes;        assert primeSize <= 63;        this.primeSize = primeSize;        // generate prime number which satisfying prime mod 2n = 1        generatePrimes(2 * polyModulusDegree);        // nttContext        generateNttContexts();        modulus = BigInteger.ONE;        for (long prime : primes) {            modulus = modulus.multiply(BigInteger.valueOf(prime));        }        preComputeCrt();    }    public long[] crt(BigInteger value) {        long[] result = new long[numPrimes];        for (int i = 0; i < numPrimes; i++) {            result[i] = value.mod(BigInteger.valueOf(primes[i])).longValue();        }        return result;    }    public long[] crt(long value) {        long[] result = new long[numPrimes];        for (int i = 0; i < numPrimes; i++) {            result[i] = value % primes[i];        }        return result;    }    public BigInteger reconstruct(long[] values) {        assert values.length == numPrimes;        BigInteger result = BigInteger.ZERO;        for (int i = 0; i < numPrimes; i++) {            // long * long 再取模，会有溢出风险吗？            // 实测是有的，只有转换为 BigInteger 然后再计算//            long temp1 = (values[i] * crtInvValues[i]) % primes[i];            BigInteger temp1 = BigInteger.valueOf(values[i]).multiply(BigInteger.valueOf(crtInvValues[i])).mod(BigInteger.valueOf(primes[i]));            BigInteger temp2 = temp1.multiply(crtValues[i]).mod(modulus);            result = result.add(temp2).mod(modulus);        }        return result;    }    private void preComputeCrt() {        // 一定要用 BigInteger 来存吗？有没有优化的方法？        crtValues = new BigInteger[numPrimes];        crtInvValues = new long[numPrimes];        for (int i = 0; i < numPrimes; i++) {            crtValues[i] = modulus.divide(BigInteger.valueOf(primes[i]));            crtInvValues[i] = crtValues[i].modInverse(BigInteger.valueOf(primes[i])).longValue();//        Inverse(BigInteger.valueOf(primes[i])).longValue();        }    }    private void generatePrimes(int modulus) {        primes = new long[numPrimes];        long candidatePrime = (1L << primeSize) + 1;        for (int i = 0; i < numPrimes; i++) {            while (!BigInteger.valueOf(candidatePrime).isProbablePrime(CommonConstants.STATS_BIT_LENGTH)) {                candidatePrime += modulus;            }            primes[i] = candidatePrime;            candidatePrime += modulus;        }    }    private void generateNttContexts() {        nttContexts = new NttContext[numPrimes];        for (int i = 0; i < numPrimes; i++) {            NttContext nttContext = new NttContext(polyModulusDegree, primes[i]);            nttContexts[i] = nttContext;        }    }}